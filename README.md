# CritterEvo

## Overview

CritterEvo is a Java-based artificial life simulator, inspired by evolutionary biology and game theory, used to model evolutionary dynamics within an artificial ecosystem. Players configure parameters such as world size, resource distribution, and mutation rates to customize a procedurally generated grid-based world populated by autonomous critters whose main goal is to survive and reproduce. Critters interact with their environment and each other, making decisions based on inputs like hunger, thirst, proximity to resources, and population density. Using genetic algorithms and natural selection, these critters adapt over generations, developing unique behavior and trait sets optimized for survival. 

I created this simulation because I was very interested in how I could recreate the biological process of evolution using concepts I learned in my CS and Networks (game theory) classes. As such, everything in this program: classes, data structures, algorithms, etc., are all written and implemented from scratch in vanilla Java (and Swing for the GUI).

To run the simulation for yourself, install Java on your machine, then download the source code or clone the repository into a directory of your choosing, and run the main `CritterEvoGame` class, located in `src/view/CritterEvoGame.java`.

## Core Features and Systems

### World Generation
The world is a simple square-based grid populated by critters, food, mountains, and water. The world itself is procedurally generated to include varied terrain and natural features such as mountain ranges and lakes. To create natural looking terrain, I used Simplex noise (credit to KdotJPG's [OpenSimplex2 noise generator](https://github.com/KdotJPG/OpenSimplex2)), where for each (x, y) coordinate, a noise output is generated. The output is then processed using four octaves, which adds layers of detail ranging from small to large, and normalized to a value in between 0 and 1. This final value is then mapped to a specific terrain feature, such as grass, mountain, or water. At world generation, user-defined initial food and critter density parameters are used to then seed the world with an initial populace of random critters and food. Additional parameters such as size cost, base movement and rotation costs, damage scaling, mutation rate, base hunger and thirst expenditure, and terrain scale can be modified at world generation to customize the world. 

### Simulation Cycle
The simulation runs on a turn-based cycle. At each turn, each individual critter makes a move mutating the state of the world, and the simulation then compiles this data and uses it to update the GUI. GUI updates are executed on the Swing Event Dispatch Thread to avoid concurrency issues and to speed up performance. Users can control the simulation speed via a slider.

### Modeling Natural Selection and Evolution
Each critter has attributes, such as health, age, hunger, thirst, aggression, offense, defense, vision, etc. that determine its behavior and overall fitness. When the critter reaches a certain set of conditions, it will reproduce to create a child critter. Whenever the critter reproduces, the child has a small chance of mutation, determined by the parent's and base world mutation rate. Each physical trait is independently chanced for mutation, where its value is changed by up to 20%. Over thousands of generations, these mutations allow for dominant sets of traits to emerge, weeding out critters that are not fit, essentially producing a simplified version of natural selection. In my very early preliminary testing, the critters already evolve to occupy certain niches and roles in the ecosystem. By noting the distribution and modality on each individual trait, it seems that a simple food chain develops, where "herbivores", "carnivores", and "omnivores" emerge, with sometimes even more nuanced speciation within each subcategory. It's incredibly interesting to observe, and I'm excited to see where it goes as I make the simulation and the critters that inhabit it increasingly complex. 

### Critters: Artificial Intelligence
As outlined above, each critter has physical attributes that determine its behavior and overall fitness.  Additionally, each critter has a "brain" i.e. a neural network to make decisions. Inputs to the network include health, hunger, thirst, amount of water and food nearby, the distance to the nearest food and water, aggression, and population density. The network's output uses this input to then determine the critter's next action, such as seeking food, seeking water, reproducing, resting, or attacking another critter. This network is essentially responsible for making high-level decisions for the critter - that is, its priority, or what it "wants" to do. Once the output from the network is calculated, it is then sent to a scoring function that locates all potential targets corresponding to the critter's priority, and assigns a probabilistic score to each target based on modifiers derived from the critter's attributes and state. Based on all the scores, a target is then chosen and finally sent to the pathfinding algorithm to determine the best path for the critter to take to the target. 

The simulation employs the NEAT algorithm (NeuroEvolution of Augmenting Topologies), a genetic algorithm for the evolution of artificial neural networks developed by Kenneth Stanley and Risto Miikkulainen in 2002 while at the University of Texas Austin. I encourage you to read the [original research paper](https://nn.cs.utexas.edu/downloads/papers/stanley.cec02.pdf) to understand the granular details on how the algorithm works. In short, the algorithm starts with a perceptron-like feed-forward network of only input and output neurons. Each neuron in the network is a "node gene", and each connection or synapse within the network is a "connection gene". Each connection gene holds data on its two endpoint genes, its weight and bias, whether it is expressed or not, and an "innovation number", used for gene identification during crossovers and mutation. As stated above, when each critter reproduces, its child has a small chance at mutation. This not only applies to the critter's physical traits, but also its intelligence. In the NEAT algorithm, these mutations can change both connection weights and network structures through the addition or removal of neurons and synapses. Similar to how its physical traits determine its fitness, each critter's AI also plays a large role in determining its survival. Over time, unintelligent critters are weeded out, and certain network structure patterns develop, resulting in emergent behavior. This eliminates the need for supervised training, as natural selection dictates what is a "good" network. 

### Critters: Pathfinding
In the early stages of development, critters simply located and moved towards their target in a straight line. After I added terrain, this became insufficient, as critters would lock on a target and attempt to cross untraversable terrain such as mountains, get stuck, and die. To solve this problem, I implemented the A* search algorithm (a generalization of Dijkstra's algorithm) for critter pathfinding, where the heuristic function takes in factors such as terrain steepness and target value. This allows the critters to be smarter in their movement and navigate around obstacles efficiently. A major challenge I faced while implementing the algorithm was the constantly changing world state, which made it difficult to create an efficient graph abstraction for the algorithm. To address this, instead of building a graph structure with defined vertices and edges, critters dynamically calculate their paths directly on the existing world grid. This approach ensures the paths are always synchronized with the world grid, is significantly more efficient in terms of time and space, and naturally lends itself to the use of multithreading.

### Performance
When developing this simulation, performance quickly became a very large issue. It was very computationally expensive to update the Critter and World state over and over again, especially taking into account the performance-heavy operations, such as pathfinding. As such, the simulation grew exponentially slower the larger I set the world dimensions. To alleviate this, I implemented several strategies aimed at improving performance. 

The main strategy I took was the use of multithreading. By default, when you run a Java program, the Java Virtual Machine automatically creates the main thread, which executes the `main()` thread. Program instructions are then sequentially executed on this single thread. Luckily, Java provides robust support for multithreading, which allows tasks to be executed and completed in parallel, or concurrently. I created a `ThreadPool` class, which serves as an abstraction barrier over Java's `ExecutorService` framework. When constructed, `ThreadPool` creates a fixed-size pool of threads - in my program this size is set to the number of cores on the machine's CPU - which accepts and executes tasks provided to it. In this program, a number of operations utilize this thread pool, allowing tasks within the simulation to be executed concurrently on multiple threads, greatly improving performance.

Another optimization that I implemented was the use of lazy updating. Rather than updating and repainting the entire world on each tick, I instead kept track of "dirty cells" - that is, squares whose state changed from one tick to the next. Only these dirty cells are subsequently updated, saving a large chunk of performance.

The final optimization that I implemented, specifically within the pathfinding algorithm, was the use of path caching. The A* algorithm, when performed individually for a very large number of critters, is very expensive. To somewhat improve performance, I initialized a cache of already created paths, which is searched through when a critter first begins a pathfinding operation. If a path matching the critter's request is found in the cache, the matching path is used instead of calculating a new path, reducing the number of calls to the algorithm, and therefore improving performance.

With all these optimizations, I was able to create a world of over 1500 by 1500 squares and run it without the program crashing, albeit very slowly. To put the scale of that into perspective, that is over two *million* squares. Obviously, this number will vary depending on the power of your CPU - adjust to the power of your CPU accordingly. I would recommend keeping the dimensions of the world below 150 by 150 for both performance and practicality purposes - any larger and the simulation speed noticeably slows down and it becomes hard to see what is happening.
